/**
 * Copyright (c) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.md file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.jira;

import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.InvalidateConnectionOn;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.display.Password;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;

import com.atlassian.jira.rest.client.api.JiraRestClient;
import com.atlassian.jira.rest.client.api.JiraRestClientFactory;
import com.atlassian.jira.rest.client.api.domain.BasicUser;
import com.atlassian.jira.rest.client.api.domain.Issue;
import com.atlassian.jira.rest.client.api.domain.Project;
import com.atlassian.jira.rest.client.api.domain.input.FieldInput;
import com.atlassian.jira.rest.client.api.domain.input.IssueInput;
import com.atlassian.jira.rest.client.api.domain.input.WorklogInput;
import com.atlassian.jira.rest.client.api.domain.input.WorklogInput.AdjustEstimate;
import com.atlassian.jira.rest.client.internal.async.AsynchronousJiraRestClientFactory;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;

import org.joda.time.DateTime;

/**
 * MuleSoft connector to interface with the Jira  API
 * <p/>
 * REST is the recommended and supported remote API in JIRA 5.0 and later. This is where Atlassian will focus its attention from this point onwards, adding functionality and fixing bugs.
 *
 * @author MuleSoft, Inc.
 */
@Connector(name = "jira", schemaVersion = "2.0", friendlyName = "Jira")
public class JiraRESTConnector
{

    private String jiraUrl;

    private JiraRestClient client;

    private String user;

    /**
     * Set the Jira URL to connect to
     *
     * @param jiraUrl of the instance
     */
    public void setJiraUrl(final String jiraUrl)
    {
        this.jiraUrl = jiraUrl;
    }

    public String getJiraUrl()
    {
        return this.jiraUrl;
    }

    /**
     * Connect to the configured jiraUrl
     *
     * @param username to use
     * @param password to use
     * @param jiraUrl  Jira instance's URL to connect to
     * @throws ConnectionException
     */
    @Connect
    public void connect(final @ConnectionKey String username, final @Password String password, String jiraUrl) throws ConnectionException
    {
        final JiraRestClientFactory factory = new AsynchronousJiraRestClientFactory();
        try
        {
            final URI jiraServerUri = new URI(jiraUrl);
            client = factory.createWithBasicHttpAuthentication(jiraServerUri, username, password);
            this.user = username;
            this.jiraUrl = jiraUrl;
        }
        catch (URISyntaxException e)
        {
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN_HOST, "", jiraUrl + " doesn't seem to be a valid URL");
        }
    }

    /**
     * Disconnect
     *
     * @throws IOException if something fails
     */
    @Disconnect
    public void disconnect() throws IOException
    {
        if (client != null)
        {
            client.close();
            client = null;
        }
    }

    /**
     * Are we connected?
     */
    @ValidateConnection
    public boolean isConnected()
    {
        return client != null;
    }

    /**
     * A way to identify the connection
     */
    @ConnectionIdentifier
    public String connectionId()
    {
        return this.user;
    }

    /**
     * Get an issue given its key
     * <p/>
     *
     * @param issueKey The key of the issue to get
     * @return the requested Issue
     */
    @Processor
    @InvalidateConnectionOn(exception = JiraClientAuthenticationException.class)
    public Issue getIssue(final String issueKey)
    {
        return JiraRestClientCallWrapper.wrap(new JiraRestClientInvocation<Issue>()
        {
            @Override
            public Issue invoke()
            {
                return client.getIssueClient().getIssue(issueKey).claim();
            }
        });
    }

    /**
     * Creates a new issue given its key
     * <p/>
     *
     * @return the created Issue key
     */
    @Processor
    @InvalidateConnectionOn(exception = JiraClientAuthenticationException.class)
    public String createIssue(@Optional @Default("#[payload]") final Map<String, Object> issueData)
    {
        return JiraRestClientCallWrapper.wrap(new JiraRestClientInvocation<String>()
        {
            @Override
            public String invoke()
            {
                return client.getIssueClient().createIssue(toIssueInput(issueData)).claim().getKey();
            }
        });
    }

    private IssueInput toIssueInput(Map<String, Object> issueData)
    {
        FieldInput[] fields = new FieldInput[issueData.size()];
        int i = 0;
        for (Map.Entry<String, Object> issueFields : issueData.entrySet())
        {

            String key = issueFields.getKey();
            Object value = issueFields.getValue();
            fields[i] = new FieldInput(key, value);
            i++;

        }
        return IssueInput.createWithFields(fields);

    }

    /**
     * Get a project given its key
     * <p/>

     *
     * @param projectKey The key of the project to get
     * @return the requested Project
     */
    @Processor
    @InvalidateConnectionOn(exception = JiraClientAuthenticationException.class)
    public Project getProject(final String projectKey)
    {
        return JiraRestClientCallWrapper.wrap(new JiraRestClientInvocation<Project>()
        {
            @Override
            public Project invoke()
            {
                return client.getProjectClient().getProject(projectKey).claim();
            }
        });
    }


    /**
     * Add an effort to an issue's worklog
     * <p/>
     *
     * @param issue     in which to add the effort
     * @param authorUri uri of the author of the effort
     * @param date      in which the effort should be created
     * @param minutes   spent
     * @param comment   to add to the effort
     * @return nothing
     * @throws URISyntaxException when the URI is not well formed
     */
    @Processor
    @InvalidateConnectionOn(exception = JiraClientAuthenticationException.class)
    public Void addEffort(@Optional @Default("#[payload]") final Issue issue, final String authorUri, final DateTime date, final int minutes, final @Optional String comment) throws URISyntaxException
    {
        final URI actualAuthorUri = new URI(authorUri);
        return JiraRestClientCallWrapper.wrap(new JiraRestClientInvocation<Void>()
        {
            @Override
            public Void invoke()
            {
                final BasicUser author = new BasicUser(actualAuthorUri, null, null);
                final WorklogInput worklog = new WorklogInput(null, issue.getSelf(), author, author, comment, date, minutes, null, AdjustEstimate.AUTO, null);
                return client.getIssueClient().addWorklog(issue.getWorklogUri(), worklog).claim();
            }
        });
    }

    /**
     * Upload an attachment to the issue
     * <p/>
     *
     * @param issue    in which to upload the attachment to
     * @param in       InputStream of the file's content
     * @param filename of the attachment
     * @return nothing
     */
    @Processor
    @InvalidateConnectionOn(exception = JiraClientAuthenticationException.class)
    public Void uploadAttachment(@Optional @Default("#[payload]") final Issue issue, final InputStream in, final String filename)
    {
        return JiraRestClientCallWrapper.wrap(new JiraRestClientInvocation<Void>()
        {
            @Override
            public Void invoke()
            {
                return client.getIssueClient().addAttachment(issue.getAttachmentsUri(), in, filename).claim();
            }
        });
    }


}
